#!/bin/bash

# usage: taxonomy_round1.sh <path to directory containing otu file labelled: 18S.otus.nonchimeras.fasta>

# Requires that the following softwares are installed and in your path:
## ncbi-blast+ version 2.9.0-2 or newer
## raxml version 8.2.10 or newer (I dont use raxml-ng here as the GTRCAT model which is faster, was not available)
## mafft version 7.310 or newer
## trimal version 1.2rev59 or newer

DIR=$1
SAMPLE=$(echo $DIR | sed -E 's/.*\/(.*)/\1/')
DB="PR2/transitions/pr2.transitions.db"		## change me to the correct path - fasta file available on figshare. Make blastdb.
FASTA="PR2/transitions/pr2.transitions.fasta"	## change me to the correct path - fasta file available on figshare.
EUKREF="PR2/transitions/pr2.main_groups.fasta"	## change me to the correct path - available on github
THREADS=10
RAXML="/opt/raxmlHPC-PTHREADS-SSE3"	## change me to correct path and version (AVX/SSE3 etc.)


### change to right directory
cd $DIR

### log
exec > taxonomy_round1.log 2>&1

## First fix the headers of the fasta file. Replace '/' with '_' for ease downstream
cat 18S.otus.nonchimeras.fasta | tr '/' '_' > 18S.otus.fixed.fasta

## Blast against PR2 database
blastn -query 18S.otus.fixed.fasta -db "$DB" -num_threads $THREADS -out 18S.otus.fixed_vs_pr2.blastn -outfmt '6 std salltitles'

## Get top 50 hits for each sequence

mkdir blasthits
for header in $(cut -f1 18S.otus.fixed_vs_pr2.blastn | sort -u); do grep -w -m 50 "$header" 18S.otus.fixed_vs_pr2.blastn | cut -f13 | sort -u > blasthits/"$header".top50hits.list; done

# Get the sequences for each of these hits
cd blasthits/
for i in *.top50hits.list; do cat $FASTA | seqkit grep -f "$i" > "$i".fasta; done
for i in *.fasta; do cat $i | seqkit rmdup -n -o "$i".clean; done

# Add the original query sequence to these sequences
for i in *.clean; do header=$(echo $i | awk -F '.' '{print $1}'); cat ../18S.otus.fixed.fasta | seqkit grep -p "$header" >> "$i"; done

## Calculate ML distance and extract top 2 seqs
### align sequences
for i in *.clean; do base=$(echo $i | awk -F '.' '{print $1}'); mafft --thread $THREADS --adjustdirection $i > "$base".mafft.fasta; done
### calculate ML distance
for i in *.mafft.fasta; do base=$(echo $i | awk -F '.' '{print $1}'); $RAXML -T $THREADS -f x -p 12345 -s $i -m GTRGAMMA -n "$base".out; done
rm RAxML_info.* RAxML_parsimonyTree.*

# Extract top 2 hits 
for i in RAxML_distances.*; do header=$(echo $i | awk -F '.' '{print $2}'); cat $i | sort -Vk2 | grep -m 2 "$header" > "$header".top2.tsv; done

# Move to parent directory
cat *top2.tsv | cut -f1 -d ' ' >> ../top2hits.list
cd ..

# How many references?
echo Number of references: $(cat top2hits.list | sort | uniq | wc -l)
cat top2hits.list | sort | uniq > top2hits.uniq.list

# Extract these ref seqs
cat $FASTA | seqkit grep -f top2hits.uniq.list > top2hits.fasta

# Cat everything together
cat top2hits.fasta 18S.otus.fixed.fasta $EUKREF > 18S.otus.ref.fasta
# Remove duplicates
cat 18S.otus.ref.fasta | seqkit rmdup -n -o 18S.otus.ref.clean.fasta

## Align
mafft --retree 2 --maxiterate 1000 --thread -10 --reorder --adjustdirection 18S.otus.ref.clean.fasta > 18S.otus.ref.mafft.fasta

## Trim
trimal -in 18S.otus.ref.mafft.fasta -out 18S.otus.ref.mafft.trimal.fasta -gt 0.01 -st 0.001


## Run tree with RAxML (v8 and not raxml-ng so we can use the faster GTRCAT model). Calculate SH-like support values.
$RAXML -T 3 -m GTRCAT -p $RANDOM -N 20 -s 18S.otus.ref.mafft.trimal.fasta -n "$SAMPLE".tre
$RAXML -f J -p $RANDOM -m GTRGAMMA -s 18S.otus.ref.mafft.trimal.fasta -t RAxML_bestTree.*.tre -n "$SAMPLE".sh.tre

## The file generated by RAxML cannot be opened in FigTree so I change the format of the support values to make it compatible. 
for i in RAxML_fastTreeSH_Support.*; do cat $i | sed -i -E 's/\)\:([^\[]+)\[([0-9]+)\]/\)\2\:\1/g' > tree; mv tree $i; done

## Examine the tree manually in FigTree and colour taxa that should be discarded. Mark nucleomorph sequences (green - hex code: #00FF00), mislabelled reference sequences (blue - hex code: #0000FF), and any OTU sequences that look like artefacts (ridiculously long branch for example) (magenta - hex code: #FF00FF). Nucleomorph OTU sequences are easily identified because they cluster with reference nucleomorph sequences. Mislabelled reference sequences are also easily identified, for example you may find a PR2 sequence annotated as Fungi clustering with Dinoflagellates etc. Other artefact OTU sequences (chimeras) are trickier to spot. I recommend BLASTing suspicious sequences in two halves, and using the information about abundance (in the fasta header) to help you decide which sequences to keep or not. This is an important step so take your time.



